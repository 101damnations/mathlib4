/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, ρ)`.

We first define `Representation.augmentationSubmodule`, the submodule of `V` generated by elements
of the form `ρ g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, ρ)` are the quotient of
`V` by this submodule. We show that the functor sending a representation to its coinvariants is
left adjoint to the functor equipping a module with the trivial representation.

-/

universe u v

namespace Representation

variable {k G V W : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (ρ : Representation k G V) (τ : Representation k G W)

/-- The submodule of a representation generated by elements of the form `ρ g x - x`. -/
def augmentationSubmodule : Submodule k V :=
  Submodule.span k (Set.range fun (x : G × V) => ρ x.1 x.2 - x.2)

variable {ρ}

lemma mem_augmentationSubmodule_of_eq (g : G) (x : V) (a : V) (h : ρ g x - x = a) :
    a ∈ augmentationSubmodule ρ :=
  Submodule.subset_span ⟨(g, x), h⟩

variable (ρ)

/-- The coinvariants of a representation, `V ⧸ ⟨{ρ g x - x | g ∈ G, x ∈ V}⟩`. -/
def Coinvariants := V ⧸ augmentationSubmodule ρ

namespace Coinvariants

instance : AddCommGroup (Coinvariants ρ) := by unfold Coinvariants; infer_instance
instance : Module k (Coinvariants ρ) := by unfold Coinvariants; infer_instance

/-- The quotient map from a representation to its coinvariants as a linear map. -/
def mk : V →ₗ[k] Coinvariants ρ := Submodule.mkQ (augmentationSubmodule ρ)

theorem mk_eq_iff {x y : V} :
    mk ρ x = mk ρ y ↔ x - y ∈ ρ.augmentationSubmodule :=
  Submodule.Quotient.eq _

@[simp]
lemma mk_ρ_apply (g : G) (x : V) :
    mk ρ (ρ g x) = mk ρ x :=
  (mk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq g x _ rfl

@[elab_as_elim]
theorem induction_on {C : Coinvariants ρ → Prop} (x : Coinvariants ρ) (h : ∀ v : V, C (mk ρ v)) :
    C x :=
  Submodule.Quotient.induction_on _ x h

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def lift (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
    ρ.Coinvariants →ₗ[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x ⟨⟨g, y⟩, hy⟩ => by
    simpa only [← hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

variable {ρ}

@[simp]
theorem lift_comp_mk (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
    lift ρ f h ∘ₗ mk ρ = f := rfl

@[simp]
theorem lift_mk (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) (x : V) :
    lift ρ f h (mk _ x) = f x := rfl

@[ext]
lemma hom_ext {f g : Coinvariants ρ →ₗ[k] W} (H : f ∘ₗ mk ρ = g ∘ₗ mk ρ) : f = g :=
  Submodule.linearMap_qext _ H

variable (ρ)

/-- Given `G`-representations on `k`-modules `V, W`, a linear map `V →ₗ[k] W` commuting with
the representations induces a `k`-linear map between the coinvariants. -/
noncomputable def map (f : V →ₗ[k] W) (hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f) :
    Coinvariants ρ →ₗ[k] Coinvariants τ :=
  lift _ (mk _ ∘ₗ f) fun g => LinearMap.ext fun x => (mk_eq_iff _).2 <|
    mem_augmentationSubmodule_of_eq (ρ := τ) g (f x) _ <| by simpa using congr($((hf g).symm) x)

variable {ρ τ}

@[simp]
lemma map_comp_mk {f : V →ₗ[k] W} {hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f} :
    map ρ τ f hf ∘ₗ mk ρ = mk τ ∘ₗ f := rfl

@[simp]
lemma map_mk (f : V →ₗ[k] W) (hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f) (x : V) :
    map ρ τ f hf (mk _ x) = mk _ (f x) := rfl

end Coinvariants
end Representation

namespace Rep
namespace Coinvariants

variable {k G : Type u} [CommRing k] [Monoid G] {A B C : Rep k G} {n : ℕ}

open CategoryTheory

/-- The linear map underlying a `G`-representation morphism `A ⟶ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev lift [B.ρ.IsTrivial] (f : A ⟶ B) :
    A.ρ.Coinvariants →ₗ[k] B :=
  Representation.Coinvariants.lift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

/-- A `G`-representation morphism `A ⟶ B` induces a linear map `A_G →ₗ[k] B_G`. -/
noncomputable abbrev map (f : A ⟶ B) :
    A.ρ.Coinvariants →ₗ[k] B.ρ.Coinvariants :=
  Representation.Coinvariants.map _ _ f.hom.hom fun _ => ModuleCat.hom_ext_iff.1 (f.comm _)

@[simp]
theorem map_id (A : Rep k G) :
    map (𝟙 A) = LinearMap.id := by
  ext; rfl

@[simp]
theorem map_comp (f : A ⟶ B) (g : B ⟶ C) :
    map (f ≫ g) = map g ∘ₗ map f := by
  ext; rfl

variable (k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps]
noncomputable def functor : Rep k G ⥤ ModuleCat k where
  obj A := ModuleCat.of k (A.ρ.Coinvariants)
  map f := ModuleCat.ofHom (map f)

instance : (functor k G).Additive where
  map_add := ModuleCat.hom_ext <| LinearMap.ext fun x => Quotient.inductionOn' x (fun _ => rfl)

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
noncomputable def adjunction : functor k G ⊣ trivialFunctor G :=
  Adjunction.mkOfHomEquiv {
    homEquiv X Y := {
      toFun f := {
        hom := ModuleCat.ofHom (f.hom ∘ₗ X.ρ.augmentationSubmodule.mkQ)
        comm g := by
          ext x
          exact congr(f.hom $((Submodule.Quotient.eq <| X.ρ.augmentationSubmodule).2
            (X.ρ.mem_augmentationSubmodule_of_eq g x _ rfl))) }
      invFun f := ModuleCat.ofHom (lift f)
      left_inv _ := ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl
      right_inv _ := Action.Hom.ext <| rfl }
    homEquiv_naturality_left_symm _ _ := ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl
    homEquiv_naturality_right := by intros; rfl }

instance : (functor k G).PreservesZeroMorphisms where
  map_zero _ _ := ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl

instance : Limits.PreservesColimits (functor k G) :=
  (adjunction k G).leftAdjoint_preservesColimits

end Coinvariants
end Rep
