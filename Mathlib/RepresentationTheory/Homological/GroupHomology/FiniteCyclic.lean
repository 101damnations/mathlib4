/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.RepresentationTheory.Homological.FiniteCyclic

/-!
# Group cohomology of a finite cyclic group

Let `k` be a commutative ring and `G` a finite commutative group. Given `g : G` and `A : Rep k G`,
we can define a periodic chain complex in `Rep k G` given by
`... ⟶ A --N--> A --(ρ(g) - 𝟙)--> A --N--> A --(ρ(g) - 𝟙)--> A ⟶ 0`
where `N` is the norm map. When `G` is generated by `g` and `A` is the left regular representation
`k[G]`, it is a projective resolution of `k` as a trivial representation.

yadda yadda. -/

universe v u

open CategoryTheory Representation Finsupp Limits

namespace Rep.finiteCyclicGroup

variable {k G : Type u} [CommRing k] [CommGroup G] [Fintype G] (g : G)
  (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G)

open ModuleCat.MonoidalCategory in
/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
the period chain complex
```
... ⟶ (A ⊗ₖ k[G])_G --⟦Id ⊗ N⟧--> (A ⊗ₖ k[G])_G --⟦Id ⊗ (ρ(g) - 𝟙)⟧--> (A ⊗ₖ k[G])_G ⟶ 0
```
is isomorphic as a complex in `ModuleCat k` to
```
... ⟶ A --N--> A --(ρ(g) - 𝟙)--> A --N--> A --(ρ(g) - 𝟙)--> A ⟶ 0
```
-/
@[simps!]
noncomputable def coinvariantsTensorResolutionIso {G : Type u} [CommGroup G] [Fintype G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) :
    (resolution k g⁻¹ ((@Subgroup.zpowers_inv G ..).symm ▸ hg)).complex.coinvariantsTensorObj A ≅
      moduleCatChainComplex A g :=
  HomologicalComplex.Hom.isoOfComponents
    (fun _ => (coinvariantsTprodLeftRegularLEquiv A.ρ).toModuleIso) fun i j h =>
    coinvariantsTensor_hom_ext (LinearMap.ext fun a => lhom_ext' fun g => LinearMap.ext_ring (by
    subst h
    by_cases hj : Even (j + 1)
    · simpa [hj, whiskerLeft_def, coinvariantsTensorMk, whiskerLeft,
        tensorObj_def, ofCoinvariantsTprodLeftRegular, tensorObj, Representation.norm,
        ← Module.End.mul_apply, ← map_mul, mul_comm g⁻¹]
        using Finset.sum_bijective _ (MulEquiv.inv G).bijective (by aesop) (by aesop)
    · simp [sub_eq_add_neg, hj, whiskerLeft_def, coinvariantsTensorMk,
        whiskerLeft, tensorObj_def, tensorObj, ← Module.End.mul_apply, ← map_mul, mul_comm g⁻¹]))

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, `H₀(G, A)` is isomorphic
to the cokernel of `ρ(g) - Id(A)`. -/
noncomputable def groupHomologyIso₀
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) :
    groupHomology A 0 ≅
      (ShortComplex.mk (X₃ := A.V) (applyAsHom A g - 𝟙 A).hom _ comp_zero).opcycles :=
  groupHomologyIso A 0 (resolution k g⁻¹ <| (@Subgroup.zpowers_inv G ..).symm ▸ hg) ≪≫
  HomologicalComplex.homologyMapIso (coinvariantsTensorResolutionIso g hg A) 0 ≪≫
  ChainComplex.isoHomologyι₀ _ ≪≫
  ShortComplex.opcyclesMapIso (HomologicalComplex.isoSc' _ 1 0 0 (by simp) (by simp))

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, `Hᵢ(G, A)` is isomorphic
to the homology of the short complex of `k`-modules `A --(ρ(g) - 𝟙)--> A --N--> A` when `i` is
nonzero and even. -/
noncomputable def groupHomologyEvenIso
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) [h₀ : NeZero i] (hi : Even i) :
    groupHomology A i ≅ (subCompNormHom A g).homology :=
  groupHomologyIso A i (resolution k g⁻¹ <| (@Subgroup.zpowers_inv G ..).symm ▸ hg) ≪≫
  (HomologicalComplex.homologyMapIso (coinvariantsTensorResolutionIso g hg A) i) ≪≫
  HomologicalComplex.alternatingConstHomologyEvenIso A.V (by ext; simp [sub_eq_add_neg])
    (by ext; simp [sub_eq_add_neg]) _ (by aesop)
    (by induction i generalizing h₀ with | zero => exact (NeZero.ne 0 rfl).elim | succ n _ => simp)
    hi

namespace groupHomology

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, this is the quotient map
`Ker(N) ⟶ Ker(N)/Im(ρ(g) - Id(A)) ≅ Hᵢ(G, A)` for any nonzero even `i`. -/
noncomputable abbrev πEven
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) [NeZero i] (hi : Even i) :
    ModuleCat.of k (LinearMap.ker A.ρ.norm) ⟶ groupHomology A i :=
    (ShortComplex.moduleCatCyclesIso <| subCompNormHom A g).inv ≫
      ShortComplex.homologyπ _ ≫ (groupHomologyEvenIso g hg A i hi).inv

lemma πEven_eq_zero_iff
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) [NeZero i] (hi : Even i)
    (x : LinearMap.ker A.ρ.norm) :
    πEven g hg A i hi x = 0 ↔ x.1 ∈ LinearMap.range (applyAsHom A g - 𝟙 A).hom.hom := by
  simp [πEven, map_eq_zero_iff _ ((ModuleCat.mono_iff_injective _).1 inferInstance),
    ShortComplex.moduleCatToCycles, -LinearMap.mem_range, LinearMap.range_codRestrict]

lemma πEven_eq_iff {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) [NeZero i] (hi : Even i)
    (x y : LinearMap.ker A.ρ.norm) :
    πEven g hg A i hi x = πEven g hg A i hi y ↔
      x.1 - y.1 ∈ LinearMap.range (applyAsHom A g - 𝟙 A).hom.hom := by
  rw [← sub_eq_zero, ← map_sub, πEven_eq_zero_iff]; rfl


/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, `Hⁱ(G, A)` is isomorphic
to the homology of the short complex of `k`-modules `A --N--> A --(ρ(g) - 𝟙)--> A` when `i` is
odd. -/
noncomputable def groupHomologyOddIso
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) (hi : Odd i) :
    groupHomology A i ≅ (normHomCompSub A g).homology :=
  groupHomologyIso A i (resolution k g⁻¹ <| (@Subgroup.zpowers_inv G ..).symm ▸ hg) ≪≫
  (HomologicalComplex.homologyMapIso (coinvariantsTensorResolutionIso g hg A) i) ≪≫
  HomologicalComplex.alternatingConstHomologyOddIso A.V (by ext; simp [sub_eq_add_neg])
    (by ext; simp [sub_eq_add_neg]) (by aesop) (by simp) (by rcases hi with ⟨j, rfl⟩; simp) hi

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, this is the quotient map
`Ker(ρ(g) - Id(A)) ⟶ Ker(ρ(g) - Id(A))/Im(N) ≅ Hᵢ(G, A)` for any odd `i`. -/
noncomputable abbrev πOdd
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) (hi : Odd i) :
    ModuleCat.of k (LinearMap.ker (applyAsHom A g - 𝟙 A).hom.hom) ⟶ groupHomology A i :=
    (ShortComplex.moduleCatCyclesIso <| normHomCompSub A g).inv ≫
      ShortComplex.homologyπ _ ≫ (groupHomologyOddIso g hg A i hi).inv

lemma πOdd_eq_zero_iff
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) (hi : Odd i)
    (x : LinearMap.ker (applyAsHom A g - 𝟙 A).hom.hom) :
    πOdd g hg A i hi x = 0 ↔ x.1 ∈ LinearMap.range A.ρ.norm := by
  simp [πOdd, map_eq_zero_iff _ ((ModuleCat.mono_iff_injective _).1 inferInstance),
    ShortComplex.moduleCatToCycles, -LinearMap.mem_range, LinearMap.range_codRestrict]

lemma πOdd_eq_iff {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ∀ x, x ∈ Subgroup.zpowers g) (A : Rep k G) (i : ℕ) (hi : Odd i)
    (x y : LinearMap.ker (applyAsHom A g - 𝟙 A).hom.hom) :
    πOdd g hg A i hi x = πOdd g hg A i hi y ↔
      x.1 - y.1 ∈ LinearMap.range A.ρ.norm := by
  rw [← sub_eq_zero, ← map_sub, πOdd_eq_zero_iff]; rfl

end groupHomology
end finiteCyclicGroup
end Rep
