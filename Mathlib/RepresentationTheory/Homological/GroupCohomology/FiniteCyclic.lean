/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.RepresentationTheory.Homological.FiniteCyclic
import Mathlib.RepresentationTheory.Homological.GroupCohomology.Basic

/-!
# Group cohomology of a finite cyclic group

Let `k` be a commutative ring and `G` a finite commutative group. Given `g : G` and `A : Rep k G`,
we can define a periodic chain complex in `Rep k G` given by
`... ‚ü∂ A --N--> A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A ‚ü∂ 0`
where `N` is the norm map. When `G` is generated by `g` and `A` is the left regular representation
`k[G]`, it is a projective resolution of `k` as a trivial representation.

yadda yadda. -/

universe v u

open CategoryTheory

namespace Rep.finiteCyclicGroup

variable {k G : Type u} [CommRing k] [CommGroup G] [Fintype G] (g : G)
  (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G)

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
the periodic cochain complex
```
0 ‚ü∂ Hom(k[G], A) --(- ‚àò (œÅ(g) - ùüô))--> Hom(k[G], A) --(- ‚àò N)--> Hom(k[G], A) ‚ü∂ ...
```
is isomorphic as a complex in `ModuleCat k` to
```
0 ‚ü∂ A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A --N--> A ‚ü∂ ...
```
-/
@[simps!]
noncomputable def homResolutionIso :
    (resolution k g hg).complex.linearYonedaObj k A ‚âÖ moduleCatCochainComplex A g :=
  HomologicalComplex.Hom.isoOfComponents (fun _ => (leftRegularHomEquiv A).toModuleIso) <| by
    rintro i j ‚ü®rfl‚ü©
    ext (x : leftRegular _ _ ‚ü∂ _)
    by_cases hi : Even i
    ¬∑ have : ¬¨(Even (i + 1)) := (not_iff_comm.1 Nat.even_add_one.symm).2 hi
      simp [hi, this, sub_eq_add_neg, ‚Üê hom_comm_apply x]
    ¬∑ simp [hi, Nat.even_add_one.2 hi, Representation.norm,
        ‚Üê hom_comm_apply x]

open ShortComplex Limits

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, `H‚Å∞(G, A)` is isomorphic
to the kernel of `œÅ(g) - Id(A)`. -/
noncomputable def groupCohomologyIso‚ÇÄ
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) :
    groupCohomology A 0 ‚âÖ (mk _ (applyAsHom A g - ùüô A).hom (zero_comp (X := A.V))).cycles :=
  groupCohomologyIso A 0 (resolution k g hg) ‚â™‚â´
  HomologicalComplex.homologyMapIso (homResolutionIso g hg A) 0 ‚â™‚â´
  (CochainComplex.isoHomologyœÄ‚ÇÄ _).symm ‚â™‚â´
  cyclesMapIso (HomologicalComplex.isoSc' _ 0 0 1 (by simp) (by simp))

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, `H‚Å±(G, A)` is isomorphic
to the homology of the short complex of `k`-modules `A --N--> A --(œÅ(g) - ùüô)--> A` when `i` is
nonzero and even. -/
noncomputable def groupCohomologyEvenIso
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) [h‚ÇÄ : NeZero i] (hi : Even i) :
    groupCohomology A i ‚âÖ (normHomCompSub A g).homology :=
  groupCohomologyIso A i (resolution k g hg) ‚â™‚â´
  (HomologicalComplex.homologyMapIso (homResolutionIso g hg A) i) ‚â™‚â´
  HomologicalComplex.alternatingConstHomologyEvenIso A.V
    (by ext; simp [sub_eq_add_neg]) (by ext; simp [sub_eq_add_neg]) (by simp)
    (by induction i generalizing h‚ÇÄ with | zero => exact (NeZero.ne 0 rfl).elim | succ n _ => simp)
    (by simp) hi

open groupCohomology

namespace groupCohomology

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, this is the quotient map
`Ker(œÅ(g) - Id(A)) ‚ü∂ Ker(œÅ(g) - Id(A))/Im(N) ‚âÖ H‚Å±(G, A)` for any nonzero even `i`. -/
noncomputable abbrev œÄEven
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) [NeZero i] (hi : Even i) :
    ModuleCat.of k (LinearMap.ker (applyAsHom A g - ùüô A).hom.hom) ‚ü∂ groupCohomology A i :=
    (moduleCatCyclesIso <| normHomCompSub A g).inv ‚â´
      ShortComplex.homologyœÄ _ ‚â´ (groupCohomologyEvenIso g hg A i hi).inv

lemma œÄEven_eq_zero_iff
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) [NeZero i] (hi : Even i)
    (x : LinearMap.ker (applyAsHom A g - ùüô A).hom.hom) :
    œÄEven g hg A i hi x = 0 ‚Üî x.1 ‚àà LinearMap.range A.norm.hom.hom := by
  simp [œÄEven, map_eq_zero_iff _ ((ModuleCat.mono_iff_injective _).1 inferInstance),
    moduleCatToCycles, -LinearMap.mem_range, LinearMap.range_codRestrict]

lemma œÄEven_eq_iff {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) [NeZero i] (hi : Even i)
    (x y : LinearMap.ker (applyAsHom A g - ùüô A).hom.hom) :
    œÄEven g hg A i hi x = œÄEven g hg A i hi y ‚Üî x.1 - y.1 ‚àà LinearMap.range A.norm.hom.hom := by
  rw [‚Üê sub_eq_zero, ‚Üê map_sub, œÄEven_eq_zero_iff]; rfl

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, `H‚Å±(G, A)` is isomorphic
to the homology of the short complex of `k`-modules `A --(œÅ(g) - ùüô)--> A --N--> A` when `i` is
odd. -/
noncomputable def groupCohomologyOddIso
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) (hi : Odd i) :
    groupCohomology A i ‚âÖ (subCompNormHom A g).homology :=
  groupCohomologyIso A i (resolution k g hg) ‚â™‚â´
  (HomologicalComplex.homologyMapIso (homResolutionIso g hg A) i) ‚â™‚â´
  HomologicalComplex.alternatingConstHomologyOddIso A.V (by ext; simp [sub_eq_add_neg])
    (by ext; simp [sub_eq_add_neg]) (by simp) (by rcases hi with ‚ü®j, rfl‚ü©; simp) (by simp) hi

/-- Given a finite cyclic group `G` generated by `g` and `A : Rep k G`, this is the quotient map
`Ker(N) ‚ü∂ Ker(N)/Im(œÅ(g) - Id(A)) ‚âÖ H‚Å±(G, A)` for any odd `i`. -/
noncomputable abbrev œÄOdd
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) (hi : Odd i) :
    ModuleCat.of k (LinearMap.ker A.norm.hom.hom) ‚ü∂ groupCohomology A i :=
    (moduleCatCyclesIso <| subCompNormHom A g).inv ‚â´
      ShortComplex.homologyœÄ _ ‚â´ (groupCohomologyOddIso g hg A i hi).inv

lemma œÄOdd_eq_zero_iff
    {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) (hi : Odd i)
    (x : LinearMap.ker A.norm.hom.hom) :
    œÄOdd g hg A i hi x = 0 ‚Üî x.1 ‚àà LinearMap.range (applyAsHom A g - ùüô A).hom.hom := by
  simp [œÄOdd, map_eq_zero_iff _ ((ModuleCat.mono_iff_injective _).1 inferInstance),
    moduleCatToCycles, -LinearMap.mem_range, LinearMap.range_codRestrict]

lemma œÄOdd_eq_iff {G : Type u} [CommGroup G] [Fintype G] [DecidableEq G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) (A : Rep k G) (i : ‚Ñï) (hi : Odd i)
    (x y : LinearMap.ker A.norm.hom.hom) :
    œÄOdd g hg A i hi x = œÄOdd g hg A i hi y ‚Üî
      x.1 - y.1 ‚àà LinearMap.range (applyAsHom A g - ùüô A).hom.hom := by
  rw [‚Üê sub_eq_zero, ‚Üê map_sub, œÄOdd_eq_zero_iff]; rfl

end groupCohomology
end Rep.finiteCyclicGroup
