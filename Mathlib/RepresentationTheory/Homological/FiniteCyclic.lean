
/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.AlternatingConst
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.RepresentationTheory.Homological.Resolution

/-!
# Projective resolution of `k` as a trivial `k`-linear representation of a finite cyclic group

Let `k` be a commutative ring and `G` a finite commutative group. Given `g : G` and `A : Rep k G`,
we can define a periodic chain complex in `Rep k G` given by
`... ‚ü∂ A --N--> A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A ‚ü∂ 0`
where `N` is the norm map. When `G` is generated by `g` and `A` is the left regular representation
`k[G]`, it is a projective resolution of `k` as a trivial representation, which we prove here.

yadda yadda. -/

universe v u

open CategoryTheory

namespace Action

variable (V : Type*) [Category V] {G H : Type*} [Monoid G] [Monoid H] (f : G ‚âÉ* H)

instance : (res V (f : G ‚Üí* H)).IsEquivalence :=
  Functor.IsEquivalence.mk' (res V f.symm)
    (NatIso.ofComponents (fun _ => Action.mkIso (Iso.refl _) <| by simp) <| by aesop)
    (NatIso.ofComponents (fun _ => Action.mkIso (Iso.refl _) <| by simp) <| by aesop)

end Action

section

variable {G : Type*} [Group G]

open Additive Multiplicative

@[simp]
lemma ZMod.mem_zmultiples_one {n : ‚Ñï} (x : ZMod n) : x ‚àà AddSubgroup.zmultiples 1 :=
  match n with
  | 0 => ‚ü®x, by simp‚ü©
  | n + 1 => ‚ü®x.1, by simp [ZMod]‚ü©

theorem mem_zmultiples_ofMul_iff {x : Additive G} {y : G} :
    x ‚àà AddSubgroup.zmultiples (Additive.ofMul y) ‚Üî x.toMul ‚àà Subgroup.zpowers y :=
  ‚ü®fun ‚ü®z, hz‚ü© => ‚ü®z, by simp [‚Üê hz]‚ü©, fun ‚ü®z, hz‚ü© => ‚ü®z, Additive.toMul.injective <| by simp_all‚ü©‚ü©

theorem mem_zpowers_ofAdd_iff {G : Type*} [AddGroup G] {x : Multiplicative G} {y : G} :
    x ‚àà Subgroup.zpowers (Multiplicative.ofAdd y) ‚Üî x.toAdd ‚àà AddSubgroup.zmultiples y :=
  ‚ü®fun ‚ü®z, hz‚ü© => ‚ü®z, by simp [‚Üê hz]‚ü©,
   fun ‚ü®z, hz‚ü© => ‚ü®z, Multiplicative.toAdd.injective <| by simp_all‚ü©‚ü©

end

namespace Rep

open Multiplicative

variable {k G : Type u} [CommRing k] [CommMonoid G]
variable (A : Rep k G)

/-- Given a representation `A` of a commutative monoid `G`, the map `œÅ_A(g)` is a representation
morphism `A ‚ü∂ A` for any `g : G`. -/
@[simps]
noncomputable def applyAsHom (g : G) : A ‚ü∂ A where
  hom := ModuleCat.ofHom (A.œÅ g)
  comm _ := by ext; simp [‚Üê Module.End.mul_apply, ‚Üê map_mul, mul_comm]

@[reassoc, elementwise]
lemma applyAsHom_comm {A B : Rep k G} (f : A ‚ü∂ B) (g : G) :
    A.applyAsHom g ‚â´ f = f ‚â´ B.applyAsHom g := by
  ext
  simp [hom_comm_apply]

end Rep

namespace Rep.finiteCyclicGroup

open ShortComplex

variable (k : Type u) {G : Type u} [CommRing k] [CommGroup G] [Fintype G] (A : Rep k G) (g : G)

/-- Given a finite group `G` and `g : G`, this is the functor `Rep k G ‚•§ ChainComplex (Rep k G) ‚Ñï`
sending `A : Rep k G` to the periodic chain complex in `Rep k G` given by
```
... ‚ü∂ A --N--> A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A ‚ü∂ 0
```
where `N` is the norm map. When `G` is generated by `g` and `A` is the left regular representation
`k[G]`, it is a projective resolution of `k` as a trivial representation.

It sends a morphism `f : A ‚ü∂ B` to the chain morphism defined by `f` in every degree. -/
@[simps]
noncomputable def chainComplexFunctor : Rep k G ‚•§ ChainComplex (Rep k G) ‚Ñï where
  obj A := HomologicalComplex.alternatingConst A (œÜ := A.norm) (œà := applyAsHom A g - ùüô A)
    (by ext; simp [sub_eq_add_neg]) (by ext; simp [sub_eq_add_neg])
    fun _ _ => ComplexShape.down_nat_odd_add
  map f := {
    f i := f
    comm' := by
      rintro i j ‚ü®rfl‚ü©
      by_cases hj : Even (j + 1)
      ¬∑ simp [if_pos hj, norm_comm]
      ¬∑ simp [if_neg hj, applyAsHom_comm] }
  map_id _ := rfl
  map_comp _ _ := rfl

/-- Given an isomorphism of finite groups `f : G ‚âÉ* G'` and elements `g : G, g' : G'` such that
`f g = g'`, this is a natural isomorphism between the functor sending `A : Rep k G'` to the
periodic complex
```
... ‚ü∂ Res(f)(A) --Res(f)(N)--> Res(f)(A) --Res(f)((œÅ(g') - ùüô))--> Res(f)(A) ‚ü∂ 0
```
and the functor sending `A : Rep k G'` to the periodic complex
```
... ‚ü∂ Res(f)(A) --N--> A --(œÅ(g) - ùüô)--> Res(f)(A) ‚ü∂ 0
```
-/
@[simps! hom_app_f inv_app_f]
noncomputable def chainComplexFunctorCompResNatIso
    {G G' : Type u} [CommGroup G] [Fintype G] [CommGroup G']
    [Fintype G'] (f : G ‚âÉ* G') {g : G} {g' : G'} (hg : f g = g') :
    chainComplexFunctor k g' ‚ãô (Action.res _ f).mapHomologicalComplex (ComplexShape.down ‚Ñï) ‚âÖ
      Action.res _ f ‚ãô chainComplexFunctor k g :=
  NatIso.ofComponents (fun _ => HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _) <| by
    rintro i j ‚ü®rfl‚ü©
    by_cases hj : Even (j + 1)
    ¬∑ ext
      simpa [if_pos hj, Representation.norm] using
        Finset.sum_bijective _ f.bijective (by aesop) (by aesop)
    ¬∑ ext
      simp [if_neg hj, sub_eq_add_neg, hg]) (by aesop)

variable {k}

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the short complex in `ModuleCat k` given by `A --N--> A --(œÅ(g) - ùüô)--> A`
where `N` is the norm map. Its homology is `H‚Å±(G, A)` for even `i` and `H·µ¢(G, A)` for odd `i`. -/
noncomputable abbrev normHomCompSub : ShortComplex (ModuleCat k) :=
  mk A.norm.hom (applyAsHom A g - ùüô A).hom (by ext; simp [sub_eq_add_neg])

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the short complex in `ModuleCat k` given by `A --N--> A --(œÅ(g) - ùüô)--> A`
where `N` is the norm map. Its homology is `H‚Å±(G, A)` for even `i` and `H·µ¢(G, A)` for odd `i`. -/
noncomputable abbrev subCompNormHom : ShortComplex (ModuleCat k) :=
  mk (applyAsHom A g - ùüô A).hom A.norm.hom (by ext; simp [sub_eq_add_neg])

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the periodic chain complex in `ModuleCat k` given by
```
... ‚ü∂ A --N--> A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A ‚ü∂ 0
```
where `N` is the norm map. Its homology is the group homology of `A`. -/
noncomputable abbrev moduleCatChainComplex : ChainComplex (ModuleCat k) ‚Ñï :=
  HomologicalComplex.alternatingConst A.V (œÜ := A.norm.hom) (œà := (applyAsHom A g - ùüô A).hom)
    (by ext; simp [sub_eq_add_neg]) (by ext; simp [sub_eq_add_neg])
    fun _ _ => ComplexShape.down_nat_odd_add

/-- Given a finite cyclic group `G` generated by `g : G` and a `k`-linear `G`-representation `A`,
this is the periodic chain complex in `Rep k G` given by
```
0 ‚ü∂ A --(œÅ(g) - ùüô)--> A --N--> A --(œÅ(g) - ùüô)--> A --N--> A ‚ü∂ ...
```
where `N` is the norm map. Its cohomology is the group cohomology of `A`. -/
noncomputable abbrev moduleCatCochainComplex : CochainComplex (ModuleCat k) ‚Ñï :=
  HomologicalComplex.alternatingConst A.V (œÜ := (applyAsHom A g - ùüô A).hom) (œà := A.norm.hom)
    (by ext; simp [sub_eq_add_neg]) (by ext; simp [sub_eq_add_neg])
    fun _ _ => ComplexShape.up_nat_odd_add

end finiteCyclicGroup

variable (k : Type u) [CommRing k]

/-- Abbreviation for `‚Ñ§/n‚Ñ§` considered as a multiplicative group in `Type u`. -/
noncomputable abbrev zModLeftRegular (n : ‚Ñï) := leftRegular k (ULift.{u} (Multiplicative (ZMod n)))

variable (n : ‚Ñï)
open Multiplicative

@[simp]
lemma _root_.Multiplicative.ofAdd_down {Œ± : Type u} [Add Œ±] (x : ULift Œ±) :
    (ofAdd x).down = ofAdd x.down := rfl

@[simp]
lemma _root_.Additive.ofMul_down {Œ± : Type u} [Mul Œ±] (x : ULift Œ±) :
    (Additive.ofMul x).down = Additive.ofMul x.down := rfl

open Finsupp

variable {k n}

lemma leftRegular_norm_apply {G : Type u} [Group G] [Fintype G] :
    ConcreteCategory.hom (leftRegular k G).norm.hom =
      (LinearMap.lsmul k _).flip ((Representation.leftRegular k G).norm (single 1 1)) ‚àò‚Çó
      linearCombination _ (fun _ => 1) := by
  ext i : 2
  simpa [Representation.norm] using Finset.sum_bijective _
    (Group.mulRight_bijective i) (by aesop) (by aesop)

lemma leftRegular_norm_eq_zero_iff {G : Type u} [Group G] [Fintype G] (x : leftRegular k G) :
    (leftRegular k G).norm.hom x = 0 ‚Üî x.linearCombination k (fun _ => (1 : k)) = 0 := by
  rw [leftRegular_norm_apply]
  constructor
  ¬∑ intro h
    simpa [norm, Representation.norm] using Finsupp.ext_iff.1 h 1
  ¬∑ intro h
    ext
    simp_all

lemma ker_leftRegular_norm_eq {G : Type u} [Group G] [Fintype G] :
    LinearMap.ker (leftRegular k G).norm.hom.hom =
      LinearMap.ker (linearCombination k (fun _ => (1 : k))) := by
  ext
  exact leftRegular_norm_eq_zero_iff _

namespace finiteCyclicGroup

variable (k : Type u) {G : Type u} [CommRing k] [CommGroup G] [Fintype G] (g : G) (A : Rep k G)

/-- Given a finite cyclic group `G` generated by `g : G`, let `P` denote the periodic chain complex
of `k`-linear `G`-representations given by
```
... ‚ü∂ k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] ‚ü∂ 0
```
where `œÅ` is the left regular representation and `N` is the norm map. This is the chain morphism
from `P` to the chain complex concentrated at 0 by the trivial representation `k` used to show `P`
is a projective resolution of `k`. It sends `x : k[G]` to the sum of its coefficients. -/
@[simps!]
noncomputable def resolution.œÄ (g : G) :
    (chainComplexFunctor k g).obj (leftRegular k G) ‚ü∂
      (ChainComplex.single‚ÇÄ (Rep k G)).obj (trivial k G k) :=
  (((chainComplexFunctor k g).obj (leftRegular k G)).toSingle‚ÇÄEquiv _).symm
    ‚ü®leftRegularHom _ 1, (leftRegularHomEquiv _).injective <| by
      simp [leftRegularHomEquiv, sub_eq_add_neg]‚ü©

end finiteCyclicGroup
namespace zModLeftRegular

lemma apply_eq_of_applyAsHom_eq [h‚ÇÄ : NeZero n]
    (x : zModLeftRegular k n) (hx : (applyAsHom (zModLeftRegular k n) ‚ü®ofAdd 1‚ü©).hom x = x)
    (i : ULift (Multiplicative (ZMod n))) :
    x i = x 1 := by
  induction n generalizing h‚ÇÄ with | zero => exfalso; aesop | succ n => _
  refine i.rec fun i => i.rec fun i => i.inductionOn rfl fun i hi => ?_
  ¬∑ rw [‚Üê hi, ‚Üê Finsupp.ext_iff.1 hx ‚ü®ofAdd i.succ‚ü©]
    simp only [applyAsHom_hom, of_œÅ, ModuleCat.hom_ofHom, Representation.ofMulAction_apply, ZMod]
    congr
    apply ULift.ext
    simp [‚Üê ofAdd_neg, ‚Üê ofAdd_add, neg_add_eq_sub, -ofAdd_sub, sub_eq_iff_eq_add]

lemma ker_applyAsHom_sub_id_le_range_norm [NeZero n] :
    LinearMap.ker (applyAsHom (zModLeftRegular k n) ‚ü®ofAdd 1‚ü© - ùüô _).hom.hom ‚â§
      LinearMap.range (zModLeftRegular k n).norm.hom.hom := by
  intro x hx
  use single 1 (x 1)
  ext j
  simpa [Representation.norm] using (apply_eq_of_applyAsHom_eq _
    (by simpa [sub_eq_add_neg, add_neg_eq_zero] using hx) j).symm

lemma _root_.Fin.neg_one : -(1 : Fin (n + 1)) = Fin.last n := by
  apply add_right_cancel (b := 1)
  norm_num

lemma _root_.Fin.succ_neg_one : (-(1 : Fin (n + 1))).succ = Fin.last (n + 1) := by
  rw [Fin.neg_one]
  norm_num

@[simp]
lemma _root_.Fin.succ_sub_one (i : Fin n) :
    i.succ - 1 = i.castSucc := by
  rw [sub_eq_iff_eq_add]
  norm_num

@[to_additive]
theorem _root_.Fin.partialProd_of_succ_eq {n : ‚Ñï} {M : Type*} [Monoid M] {f : Fin n ‚Üí M}
    (j : Fin n) {i : Fin (n + 1)} (hij : j.succ = i) :
    Fin.partialProd f i = Fin.partialProd f (Fin.castSucc j) * f j :=
  hij ‚ñ∏ Fin.partialProd_succ _ _

@[to_additive]
lemma _root_.Fin.partialProd_castSucc {n : ‚Ñï} {M : Type*} [Monoid M]
    {f : Fin (n + 1) ‚Üí M} {i : Fin (n + 1)} :
    Fin.partialProd (f ‚àò Fin.castSucc) i = Fin.partialProd f i.castSucc := by
  refine i.inductionOn ?_ ?_
  ¬∑ simp
  ¬∑ intro i hi
    simp_all [Fin.partialProd_succ]

lemma _root_.Fin.partialSum_last (x : Fin (n + 1) ‚Üí k) :
    Fin.partialSum x (Fin.last (n + 1)) = ‚àë i, x i := by
  induction' n with n hn
  ¬∑ rw [Fin.partialSum_of_succ_eq 0] <;> simp
  ¬∑ have := hn (x ‚àò Fin.castSucc)
    rw [Fin.partialSum_castSucc] at this
    rw [Fin.partialSum_of_succ_eq (Fin.last (n + 1)) (by aesop),
      Fintype.sum_eq_add_sum_subtype_ne _ (Fin.last (n + 1)), add_comm, this, add_right_inj]
    exact Finset.sum_bijective (fun i => Subtype.mk i.castSucc (Fin.castSucc_ne_last _))
      ‚ü®fun _ _ _ => by simp_all, fun x => ‚ü®x.1.castPred x.2, by simp‚ü©‚ü© (by aesop) (by aesop)

lemma ker_linearCombination_le_range_applyAsHom_sub_id [h‚ÇÄ : NeZero n] :
    LinearMap.ker (linearCombination k (fun _ => (1 : k))) ‚â§
      LinearMap.range (applyAsHom (zModLeftRegular k n) ‚ü®ofAdd 1‚ü© - ùüô _).hom.hom := by
  induction n generalizing h‚ÇÄ with | zero => exact False.elim (NeZero.ne 0 rfl) | succ n => _
  intro x hx
  use Finsupp.equivFunOnFinite.symm
    (-Fin.partialSum (x ‚àò ULift.up ‚àò ofAdd) ‚àò Fin.succ ‚àò toAdd ‚àò ULift.down)
  ext i
  refine i.rec fun i => i.rec fun i => i.cases ?_ fun i => ?_
  ¬∑ rw [LinearMap.mem_ker] at hx
    simp only [ZMod, linearCombination, coe_lsum, LinearMap.coe_smulRight, LinearMap.id_coe, id_eq,
      smul_eq_mul, mul_one, implies_true, sum_fintype] at hx
    simpa [ZMod, Fin.partialSum_of_succ_eq 0, Representation.norm, Fin.succ_neg_one,
      sub_eq_add_neg, Fin.partialSum_last, linearCombination, Finsupp.sum_fintype]
      using (Finset.sum_bijective _ (ofAdd.trans Equiv.ulift.symm).bijective
        (by aesop) (by aesop)).trans hx
  ¬∑ have := Fin.partialSum_right_neg (x ‚àò ULift.up ‚àò ofAdd) i.succ
    simp only [sub_eq_add_neg]
    simp_all [equivFunOnFinite, neg_add_eq_sub, ZMod, Fin.succ_sub_one, ‚Üê Fin.castSucc_succ]

lemma ker_norm_le_range_applyAsHom_sub_id [NeZero n] :
    LinearMap.ker (zModLeftRegular k n).norm.hom.hom ‚â§
      LinearMap.range (applyAsHom (zModLeftRegular k n) ‚ü®ofAdd 1‚ü© - ùüô _).hom.hom := by
  rw [ker_leftRegular_norm_eq]
  exact ker_linearCombination_le_range_applyAsHom_sub_id

instance [h0 : NeZero n] :
    QuasiIso (finiteCyclicGroup.resolution.œÄ k (ULift.up (ofAdd (1 : ZMod n)))) where
quasiIsoAt m := by
  induction' m with m _
  ¬∑ simp only [finiteCyclicGroup.resolution.œÄ]
    rw [ChainComplex.quasiIsoAt‚ÇÄ_iff, ShortComplex.quasiIso_iff_of_zeros' _ rfl rfl rfl]
    constructor
    ¬∑ apply (Action.forget (ModuleCat k) _).reflects_exact_of_faithful
      simpa [ShortComplex.moduleCat_exact_iff_ker_sub_range,
        HomologicalComplex.alternatingConst, ChainComplex.toSingle‚ÇÄEquiv] using
        zModLeftRegular.ker_linearCombination_le_range_applyAsHom_sub_id
    ¬∑ rw [Rep.epi_iff_surjective]
      intro x
      use single 1 x
      simp [ChainComplex.toSingle‚ÇÄEquiv]
  ¬∑ rw [quasiIsoAt_iff_exactAt' (hL := ChainComplex.exactAt_succ_single_obj ..),
        HomologicalComplex.exactAt_iff' _ (m + 2) (m + 1) m (by simp) (by simp)]
    apply (Action.forget (ModuleCat k) _).reflects_exact_of_faithful
    rw [ShortComplex.moduleCat_exact_iff_ker_sub_range]
    by_cases hm : Odd (m + 1)
    ¬∑ simpa [if_pos (Nat.even_add_one.2 (Nat.not_even_iff_odd.2 hm)),
        if_neg (Nat.not_even_iff_odd.2 hm)] using ker_applyAsHom_sub_id_le_range_norm
    ¬∑ simpa [ShortComplex.moduleCat_exact_iff_ker_sub_range, if_pos (Nat.not_odd_iff_even.1 hm),
        if_neg (Nat.not_even_iff_odd.2 <| Nat.odd_add_one.2 hm)]
      using ker_norm_le_range_applyAsHom_sub_id

end zModLeftRegular
open ZeroObject

namespace finiteCyclicGroup

variable (k : Type u) {G : Type u} [CommRing k] [CommGroup G] [Fintype G] (g : G) (A : Rep k G)

/-- Given `e : G ‚âÉ* G'`, the restriction of the left regular representation on `k[G]'` along `e`
is isomorphic to `k[G]`. -/
@[simps!]
noncomputable def _root_.Rep.leftRegular.resIsoOfMulEquiv
    {G G' : Type u} [Monoid G] [Monoid G'] (e : G ‚âÉ* G') :
    (Action.res _ (e : G ‚Üí* G')).obj (leftRegular k G') ‚âÖ leftRegular k G :=
  Action.mkIso (mapDomain.linearEquiv _ _ e.symm).toModuleIso
    fun _ => ModuleCat.hom_ext <| lhom_ext' fun _ => by ext : 1; simp
      [ModuleCat.endRingEquiv, mapDomain.linearEquiv]

open Limits

lemma quasiIso_res_map_œÄ {G G' : Type u} [CommGroup G] [Fintype G]
    [CommGroup G'] [Fintype G'] (e : G ‚âÉ* G') (g : G) (g' : G') (he : e g = g')
    [_root_.QuasiIso (resolution.œÄ k g)] :
    _root_.QuasiIso (((Action.res (ModuleCat k) (e : G ‚Üí* G')).mapHomologicalComplex _).map
      (resolution.œÄ k g')) := by
  let E : Arrow.mk (((Action.res (ModuleCat k) (e : G ‚Üí* G')).mapHomologicalComplex _).map
      (resolution.œÄ k g')) ‚âÖ Arrow.mk (resolution.œÄ k g) :=
    Arrow.isoMk ((chainComplexFunctorCompResNatIso k e he).app (leftRegular k G') ‚â™‚â´
        (chainComplexFunctor k g).mapIso (leftRegular.resIsoOfMulEquiv k e))
      ((HomologicalComplex.singleMapHomologicalComplex
        (Action.res (ModuleCat k) _) (ComplexShape.down ‚Ñï) 0).app (trivial k _ _)) <| by
      apply HomologicalComplex.to_single_hom_ext
      simpa [HomologicalComplex.singleObjXIsoOfEq, mapDomain.linearEquiv]
        using Action.hom_ext _ _ <| ModuleCat.hom_ext <| lhom_ext' fun g => by ext; simp
  exact (_root_.quasiIso_iff_of_arrow_mk_iso _ (finiteCyclicGroup.resolution.œÄ k g) E).2 ‚Äπ_‚Ä∫

open ShortComplex Representation

instance {G : Type*} [Group G] [Fintype G] (g : G) : NeZero (orderOf g) where
  out h‚ÇÄ := orderOf_eq_zero_iff.1 h‚ÇÄ <| isOfFinOrder_of_finite g

lemma resolution.quasiIso {G : Type u} [CommGroup G] [Fintype G] (g : G)
    (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) : _root_.QuasiIso (resolution.œÄ k g) := by
  let e : ULift.{u} (Multiplicative (ZMod (orderOf g))) ‚âÉ* G :=
    MulEquiv.ulift.trans (mulEquivOfOrderOfEq (g := ofAdd 1)
      (fun x => mem_zpowers_ofAdd_iff.2 <| by simp) hg (by simp))
  exact (HomologicalComplex.quasiIso_map_iff_of_preservesHomology
    (finiteCyclicGroup.resolution.œÄ k g) (Action.res (ModuleCat k)
    (e : (ULift.{u} (Multiplicative (ZMod (orderOf g))) ‚Üí* G)))).1 <|
      quasiIso_res_map_œÄ k e ‚ü®ofAdd 1‚ü© g (by simp [e, MulEquiv.ulift])

/-- Given a finite cyclic group `G` generated by `g : G`, this is the projective resolution of `k`
as a trivial `k`-linear `G`-representation given by periodic complex
```
... ‚ü∂ k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] --N--> k[G] --(œÅ(g) - ùüô)--> k[G] ‚ü∂ 0
```
where `œÅ` is the left regular representation and `N` is the norm map. -/
@[simps]
noncomputable def resolution
    {G : Type u} [CommGroup G] [Fintype G] (g : G) (hg : ‚àÄ x, x ‚àà Subgroup.zpowers g) :
    ProjectiveResolution (trivial k G k) where
  complex := (chainComplexFunctor k g).obj (leftRegular k G)
  projective _ := inferInstanceAs <| Projective (leftRegular k G)
  œÄ := (((chainComplexFunctor k g).obj (leftRegular k G)).toSingle‚ÇÄEquiv _).symm
    ‚ü®leftRegularHom _ 1, (leftRegularHomEquiv _).injective <| by
      simp [leftRegularHomEquiv, sub_eq_add_neg]‚ü©
  quasiIso := resolution.quasiIso k g hg

end Rep.finiteCyclicGroup
